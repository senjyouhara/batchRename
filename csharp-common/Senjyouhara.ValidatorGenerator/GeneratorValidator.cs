using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Senjyouhara.ValidatorGenerator;

[Generator]
public class GeneratorValidator : TypeWithAttributeGenerator
{
    internal override string AttributeName { get; } = "GeneratorAttribute";
    internal override string AttributeNamespace { get; } = "Senjyouhara.ValidatorAttribute.";

    internal override string GeneratorByMemberType(INamedTypeSymbol ClassType,
        List<(string memberFullName, string sortName, ISymbol member, IEnumerable<AttributeData> attributes)>
            valueTuples)
    {
        var str = "";
        var generatorStr = string.Empty;
        // ClassType: AudioConfigModel
        str += $"\t\tDebug.WriteLine(\"ClassType: {ClassType.Name}\");\n";
        // ClassType2: Senjyouhara.Main.Model.AudioConfigModel
        str += $"\t\tDebug.WriteLine(\"ClassType2: {ClassType.ToDisplayString()}\");\n";
        var ruleJoin = string.Empty;
        foreach (var (memberFullName, sortName, member, attributes) in valueTuples)
        {
            // memberFullName: Senjyouhara.Main.Model.AudioConfigModel.Uid
            str += $"\t\tDebug.WriteLine(\"memberFullName: {memberFullName}\");\n";
            // sortName: Uid
            str += $"\t\tDebug.WriteLine(\"sortName: {sortName}\");\n";
            var tmp = string.Join(Environment.NewLine, from attr in attributes
                let values = (from item in attr.ConstructorArguments select item.Value).ToList()
                // attr.AttributeClass.ToDisplayString(): Senjyouhara.ValidatorAttribute.NotNullAttribute NotNullAttribute
                let msg = Format(ClassType,attr.AttributeClass.ToDisplayString(), values, attr.NamedArguments, ref str)
                select msg.Length > 0 ? $"{msg}" : string.Empty);
            if (!string.IsNullOrWhiteSpace(tmp))
            {
                ruleJoin += string.Join(Environment.NewLine, $"\t\tRuleFor(x => x.{sortName})", tmp + ";\n");
            }
        }

        return $$"""
                 // <auto-generated />
                 using System;
                 using System.Diagnostics;
                 using FluentValidation;
                 using Senjyouhara.ValidatorAttribute;
                 #nullable enable
                 namespace Senjyouhara.Main;

                 public class {{ClassType.Name}}Validator : AbstractValidator<{{ClassType.ToDisplayString()}}> {
                 
                   public {{ClassType.Name}}Validator(){
                 {{ruleJoin}}
                   }
                 
                   public static void test(){
                 {{str}}
                   }
                 }
                 """;
    }

    private static string Format(INamedTypeSymbol ClassType, string attributeFullName, List<object> list,
        ImmutableArray<KeyValuePair<string, TypedConstant>> NamedArguments, ref string output)
    {
        var str = string.Empty;
        var twice = attributeFullName switch
        {
            "Senjyouhara.ValidatorAttribute.NotNullAttribute" => $".NotNull()",
            "Senjyouhara.ValidatorAttribute.NotEmptyAttribute" => $".NotEmpty()",
            "Senjyouhara.ValidatorAttribute.NotEqualAttribute" => $".NotEqual(\"{list[0]}\")",
            "Senjyouhara.ValidatorAttribute.EqualAttribute" => $".Equal(\"{list[0]}\")",
            "Senjyouhara.ValidatorAttribute.LengthAttribute" => $".Length({list[0]}, {list[1]})",
            "Senjyouhara.ValidatorAttribute.MaxLengthAttribute" => $".MaximumLength({list[0]})",
            "Senjyouhara.ValidatorAttribute.MinLengthAttribute" => $".MinimumLength({list[0]})",
            "Senjyouhara.ValidatorAttribute.LessThanOrEqualToAttribute" => $".LessThanOrEqualTo({list[0]})",
            "Senjyouhara.ValidatorAttribute.GreaterThanOrEqualToAttribute" => $".GreaterThanOrEqualTo({list[0]})",
            "Senjyouhara.ValidatorAttribute.MatchesAttribute" => $".Matches({list[0]})",
            "Senjyouhara.ValidatorAttribute.EmailAttribute" => $".EmailAddress()",
            "Senjyouhara.ValidatorAttribute.BetweenAttribute" => $".InclusiveBetween({list[0]}, {list[1]})",
            // "Senjyouhara.ValidatorAttribute.WhenAttribute" => $".When({list[0]})",
            _ => ""
        };

        if (!string.IsNullOrWhiteSpace(twice))
        {
            str += "\t\t\t" + twice;
        }

        if (attributeFullName.Equals("Senjyouhara.ValidatorAttribute.WhenAttribute") &&
            ClassType.GetMembers().FirstOrDefault(v => v.Name.Equals(list[0])) is { } member)
        {
            output += $"\t\tDebug.WriteLine(\"member: {member.Name}\");\n";
            str += $"\t\t\t.When({ClassType.ToDisplayString() + "." + list[0]})";
        }

        output += $"\t\tDebug.WriteLine(\"twice: {twice}\");\n";
        var message = (from item in NamedArguments where item.Key == "ErrorMessage" select item.Value.Value)
            .FirstOrDefault();
        if (message is not null && message is string msg && !string.IsNullOrWhiteSpace(msg))
        {
            str += $".WithMessage(\"{message}\")";
            output += $"\t\tDebug.WriteLine(\"WithMessage: {message}\");\n";
        }

        return str;
    }
}